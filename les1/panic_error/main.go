// Для закрепления навыков отложенного вызова функций, напишите программу, содержащую вызов функции, которая будет
// создавать паническую ситуацию неявно. Затем создайте отложенный вызов, который будет обрабатывать эту паническую
// ситуацию и, в частности, печатать предупреждение в консоль. Критерием успешного выполнения задания является то, что
// программа не завершается аварийно ни при каких условиях.

// Дополните функцию из п.1 возвратом собственной ошибки в случае возникновения панической ситуации. Собственная ошибка
// должна хранить время обнаружения панической ситуации. Критерием успешного выполнения задания является наличие обработки
// созданной ошибки в функции main и вывод ее состояния в консоль

// Для закрепления практических навыков программирования, напишите программу, которая создаёт один миллион пустых файлов
// в известной, пустой директории файловой системы используя вызов os.Create. Ввиду наличия определенных ограничений
// операционной системы на число открытых файлов, такая программа должна выполнять аварийную остановку. Запустите программу
// и дождитесь полученной ошибки. Используя отложенный вызов функции закрытия файла, стабилизируйте работу приложения.
// Критерием успешного выполнения программы является успешное создание миллиона пустых файлов в директории

package main

import (
	"fmt"
	"time"
)

type ErrorWithTime struct {
	text       string
	error_time string
}

func New(text string) error {
	return &ErrorWithTime{
		text:       text,
		error_time: time.Now().Format("2006-01-02 15:04:02"),
	}
}

func (e *ErrorWithTime) Error() string {
	return fmt.Sprintf("error: %s\nerror time: %s", e.text, e.error_time)
}

func make_panic() (x int, err error) {
	defer func() {
		if recover_check := recover(); recover_check != nil {
			err = New("you better not divide by zero next time...")
		}

	}()

	var divisor int
	x = 1 / divisor
	fmt.Println(x)

	return
}

func main() {

	_, err := make_panic()

	if err != nil {
		fmt.Println(err)
	}
}
